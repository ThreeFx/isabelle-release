;;; -*- lexical-binding: t; -*-

;; Copyright (C) 2018-2019 Mathias Fleury

;; Permission is hereby granted, free of charge, to any person obtaining a copy
;; of this software and associated documentation files (the "Software"), to deal
;; in the Software without restriction, including without limitation the rights
;; to use, copy, modify, merge, publish, distribute, sublicense, and-or sell
;; copies of the Software, and to permit persons to whom the Software is
;; furnished to do so, subject to the following conditions:

;; The above copyright notice and this permission notice shall be included in
;; all copies or substantial portions of the Software.

;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
;; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
;; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
;; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
;; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
;; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
;; SOFTWARE.

;;; Code:

(require 'isar-goal-mode)
(require 'lsp-decorations)

(require 'dom)
(require 'async)

(eval-when-compile (require 'subr-x))

(defvar lsp-isar-state-buffer nil "Isabelle state buffer")
(defvar lsp-isar-output-buffer nil "Isabelle output buffer")

(defvar lsp-isar-proof-cases-content nil)
(defvar lsp-isar-proof-timer nil "Current timer rendering the HTML")

(defcustom lsp-isar-maximal-time 3 "Maximal time in seconds printing can take. Use nil for infinity"
  :type '(number)
  :group 'isabelle)

(defvar lsp-isar--last-start nil "Last start time in seconds")
(defvar lsp-isar--previous-goal nil "previous outputted goal")
(defvar lsp-isar-current-output-number 0 "number of the current output")

(defcustom lsp-isar-use-async nil
  "Use asynchronous goal printing"
  :type '(bool)
  :group 'isabelle)

(defcustom lsp-isar-time-before-printing-goal 0.3
  "Time before printing goal. Use nil to avoid printing."
  :type '(number)
  :group 'isabelle)

(define-error 'abort-rendering "Abort the rendering of the state and output buffer")


(define-inline remove-quotes-from-string (obj)
  (inline-letevals (obj)
    (inline-quote (string-remove-suffix "'" (string-remove-prefix "'" ,obj)))))

(define-inline remove-parentheses-from-string (obj)
  (inline-letevals (obj)
    (inline-quote (string-remove-suffix "(" (string-remove-prefix ")" ,obj)))))

;; The function iterates over the HTML as parsed by the HTML library. As a side effect, it fills the
;; state buffer and the output buffer with the correct faces. We cannot make the function recursive,
;; as recursive is slower and fail for deep goals.
;;
;; To shorten the code, we use the define-inline which is inlined
;; during compilation.
;;
;;
;; TODO
;;
;;   - find a big example to play with the recursive function to
;; optimise the code.
;;
;;   - find a proper profiling library.
;;
;;   - don't always use the async version of the printing. At least for small goals, it should be
;; faster to use the local thread.
;;
;;  - deduplicate functions
;;
;; The (cond ...) compiles down to a jump table, except for the
;; entries that contains (or (eq ...) (eq ...)). Therefore, I
;; duplicate entries.
;;
;;
;; RESULT OF SOME INVESTIGATIONS
;;
;;   - parsing the goal is not slow during testing but can become a
;; huge issue on Isabelle theories. And profiling in emacs is as usual
;; entirely useless to find the problem.
;;
;;
;; Initially, to reduce the overhead of printing (especially when the output contains an error). The
;; typical situation is that "apply aut" is typed, which means that goal is printer once and another
;; time in the error message. This is impossible to support. Therefore, we delay the printing, such
;; that we can cancel it, if another newer version of the goal is coming. The delay was
;; experimentally set to 0.3s. If async is used, the processing is moved to another emacs
;; instance. We currently do not use any delay, although printing still has a cost on the local
;; emacs.
;;
;; The choice of async is rather random, but there are not that many options and the
;; documentation is good enough...
;;
(defun lsp-isar-parse-output (contents)
  "The function iterates over the dynamic output generated by
Isabelle (after preprocessing), in order to generate a goal that
must be printed in Emacs with the syntax highlighting.

This is function is important for performance (not as critical as
the decorations), because goals can become arbitrary long. Remark
that I have not really tried to optimise it yet. Even if the
function is less critical, emacs is single threaded and all these
functions adds up. So any optimisation would help."
  (while contents
    (let ((content (pop contents)))
      ;; (message "content = %s" content)
      (cond
	((and lsp-isar-maximal-time (> (- (time-to-seconds) lsp-isar--last-start) lsp-isar-maximal-time))
	 (signal 'abort-rendering nil))
	((eq content nil) nil)
	((eq content 'html) nil)
	((stringp content) (insert content))
	((not (listp content))
	 (message "unrecognised %s"
		  content)
	 (insert (format "%s" content)))
	(t
	 (pcase (dom-tag content)
	   ('lsp-isar-fontification
	    (let ((start-point (dom-attr content 'start-point))
		  (face (dom-attr content 'face)))
	      (let ((ov (make-overlay start-point (point))))
		(overlay-put ov 'face face))))
	   ('html
	    (setq contents (append (dom-children content) contents)))
	   ('xmlns nil)
	   ('meta nil)
	   ('link nil)
	   ('xml_body nil)
	   ('path nil)

	   ('head
	    (push (car (last (dom-children content))) contents))

	   ('body
	    (setq contents (append (dom-children content) contents)))

	   ('block
	       (insert (if (dom-attr content 'indent) " " ""))
	     (setq contents (append (dom-children content) contents)))

	   ('class
	    (setq contents (append (dom-children content) contents)))

	   ('pre
	    (setq contents (append (dom-children content) contents)))

	   ('state_message
	    (push (dom-node 'break `(('line . 1)) "\n") contents)
	    (setq contents (append (dom-children content) contents)))

	   ('information_message
	    (set-buffer lsp-isar-output-buffer)
	    (let ((start-point (point)) (face (cdr (assoc "dotted_information" lsp-isar-get-font))))
	      (push (dom-node 'lsp-isar-fontification `((start-point . ,start-point) (face . ,face)) nil) contents)
	      (setq contents (append (dom-children content) contents))))

	   ('tracing_message ;; TODO Proper colour
	    (set-buffer lsp-isar-output-buffer)
	    (let ((start-point (point)) (face (cdr (assoc "dotted_information" lsp-isar-get-font))))
	      (push (dom-node 'break `(('line . 1)) "\n") contents)
	      (push (dom-node 'lsp-isar-fontification `((start-point . ,start-point) (face . ,face)) nil) contents)
	      (setq contents (append (dom-children content) contents))))

	   ('warning_message
	    (set-buffer lsp-isar-output-buffer)
	    (let ((start-point (point)) (face (cdr (assoc "text_overview_warning" lsp-isar-get-font))))
	      (push (dom-node 'break `(('line . 1)) "\n") contents)
	      (push (dom-node 'lsp-isar-fontification `((start-point . ,start-point) (face . ,face)) nil) contents)
	      (setq contents (append (dom-children content) contents))))

	   ('legacy_message
	    (set-buffer lsp-isar-output-buffer)
	    (let ((start-point (point)) (face (cdr (assoc "text_overview_warning" lsp-isar-get-font))))
	      (push (dom-node 'break `(('line . 1)) "\n") contents)
	      (push (dom-node 'lsp-isar-fontification `((start-point . ,start-point) (face . ,face)) nil) contents)
	      (setq contents (append (dom-children content) contents))))

	   ('writeln_message
	    (set-buffer lsp-isar-output-buffer)
	    (let ((start-point (point)) (face (cdr (assoc "dotted_writeln" lsp-isar-get-font))))
	      (push (dom-node 'break `(('line . 1)) "\n") contents)
	      (push (dom-node 'lsp-isar-fontification `((start-point . ,start-point) (face . ,face)) nil) contents)
	      (setq contents (append (dom-children content) contents))))

	   ('error_message
	    (set-buffer lsp-isar-output-buffer)
	    (let ((start-point (point)) (face (cdr (assoc "text_overview_error" lsp-isar-get-font))))
	      (push (dom-node 'lsp-isar-fontification `((start-point . ,start-point) (face . ,face)) nil) contents)
	      (setq contents (append (dom-children content) contents))))

	   ('text_fold
	    (setq contents (append (dom-children content) contents)))

	   ('subgoal
	    ;;(set-buffer lsp-isar-state-buffer)
	    (setq contents (append (dom-children content) contents)))

	   ('span
	    (insert (format "%s" (car (last (dom-children content))))))

	   ('position
	    (push (car (last (dom-children content))) contents))

	   ('intensify
	    (let ((start-point (point)) (face (cdr (assoc "background_intensify" lsp-isar-get-font))))
	      (push (dom-node 'lsp-isar-fontification `((start-point . ,start-point) (face . ,face)) nil) contents)
	      (setq contents (append (dom-children content) contents))))

	   ('keyword1
	    (let ((start-point (point)) (face (cdr (assoc "text_keyword1" lsp-isar-get-font))))
	      (push (dom-node 'lsp-isar-fontification `((start-point . ,start-point) (face . ,face)) nil) contents)
	      (setq contents (append (dom-children content) contents))))

	   ('keyword2
	    (let ((start-point (point)) (face (cdr (assoc "text_keyword2" lsp-isar-get-font))))
	      (push (dom-node 'lsp-isar-fontification `((start-point . ,start-point) (face . ,face)) nil) contents)
	      (setq contents (append (dom-children content) contents))))

	   ('keyword3
	    (let ((start-point (point)) (face (cdr (assoc "text_keyword3" lsp-isar-get-font))))
	      (push (dom-node 'lsp-isar-fontification `((start-point . ,start-point) (face . ,face)) nil) contents)
	      (setq contents (append (dom-children content) contents))))

	   ('keyword4
	    (let ((start-point (point)) (face (cdr (assoc "text_keyword4" lsp-isar-get-font))))
	      (push (dom-node 'lsp-isar-fontification `((start-point . ,start-point) (face . ,face)) nil) contents)
	      (setq contents (append (dom-children content) contents))))

	   ('fixed ;; this is used to enclose other variables
	    (setq contents (append (dom-children content) contents)))

	   ('free
	    (let ((start-point (point)) (face (cdr (assoc "text_free" lsp-isar-get-font))))
	      (push (dom-node 'lsp-isar-fontification `((start-point . ,start-point) (face . ,face)) nil) contents)
	      (setq contents (append (dom-children content) contents))))

	   ('inner_string ;; TODO font
	    (setq contents (append (dom-children content) contents)))

	   ('tfree
	    (let ((start-point (point)) (face (cdr (assoc "text_tfree" lsp-isar-get-font))))
	      (push (dom-node 'lsp-isar-fontification `((start-point . ,start-point) (face . ,face)) nil) contents)
	      (setq contents (append (dom-children content) contents))))

	   ('tvar
	    (let ((start-point (point)) (face (cdr (assoc "text_tvar" lsp-isar-get-font))))
	      (push (dom-node 'lsp-isar-fontification `((start-point . ,start-point) (face . ,face)) nil) contents)
	      (setq contents (append (dom-children content) contents))))

	   ('var
	    (let ((start-point (point)) (face (cdr (assoc "text_var" lsp-isar-get-font))))
	      (push (dom-node 'lsp-isar-fontification `((start-point . ,start-point) (face . ,face)) nil) contents)
	      (setq contents (append (dom-children content) contents))))

	   ('bound
	    (let ((start-point (point)) (face (cdr (assoc "text_bound" lsp-isar-get-font))))
	      (push (dom-node 'lsp-isar-fontification `((start-point . ,start-point) (face . ,face)) nil) contents)
	      (setq contents (append (dom-children content) contents))))

	   ('skolem
	    (let ((start-point (point)) (face (cdr (assoc "text_skolem" lsp-isar-get-font))))
	      (push (dom-node 'lsp-isar-fontification `((start-point . ,start-point) (face . ,face)) nil) contents)
	      (setq contents (append (dom-children content) contents))))

	   ('sendback ;; TODO handle properly
	    (setq lsp-isar-proof-cases-content (remove-parentheses-from-string (format "%s" (dom-children content))))
	    (setq contents (append (dom-children content) contents)))

	   ('bullet
	    (insert "•")
	    (setq contents (append (dom-children content) contents)))

	   ('language
	    (setq contents (append (dom-children content) contents)))

	   ('literal
	    (setq contents (append (dom-children content) contents)))

	   ('delimiter
	    (setq contents (append (dom-children content) contents)))

	   ('entity
	    (setq contents (append (dom-children content) contents)))

	   ('paragraph
	    (setq contents (append (dom-children content) contents)))

	   ('dynamic_fact
	    (setq contents (append (dom-children content) contents)))

	   ('item
	    ;;(message "%s" (mapconcat 'lsp-isar-parse-output (dom-children content) ""))
	    (setq contents (append (dom-children content) contents))) ;; TODO line break

	   ('break
	    (let ((children (mapcar 'remove-quotes-from-string (dom-children content))))
	      (insert (if (dom-attr content 'width) " " ""))
	      (insert (if (dom-attr content 'line) "\n" ""))
	      (mapc 'insert children)))

	   ('xml_elem
	    (setq contents (append (dom-children content) contents)))

	   ('sub ;; Heuristically find the difference between sub and bsub...esub
	    (let ((children (dom-children content)))
	      (if (and
		   (not (cdr children))
		   (stringp (car children)))
		  (insert (format "\\<^sub>%s" (car children)))
		(progn
		  (insert "\\<^bsub>")
		  (push "\\<^esub>" contents))
		(setq contents (append children contents)))))

	   ('sup ;; Heuristically find the difference between sup and bsup...esup
	    ;; but we cannot do better as the information is not transmitted
	    (let ((children (dom-children content)))
	      (if (and
		   (not (cdr children))
		   (stringp (car children)))
		  (insert (format "\\<^sup>%s" (car children)))
		(progn
		  (insert "\\<^bsup>")
		  (push "\\<^esup>" contents))
		(setq contents (append children contents)))))

	   (_
	    (if (listp (dom-tag content))
		(progn
		  (message "unrecognised node %s" (dom-tag content))
		  (insert (format "%s" (dom-tag content)))
		  (mapc 'lsp-isar-parse-output (dom-children content)))
	      (progn
		(message "unrecognised content %s; node is: %s; string: %s %s"
			 content (dom-tag content) (stringp (dom-tag content)) (listp content))
		(insert (format "%s" (dom-tag content))))))))))))


(defun replace-regexp-all-occs (REGEXP TO-STRING)
  "replace-regexp as indicated in the help"
  (goto-char (point-min))
  (while (re-search-forward REGEXP nil t)
    (replace-match TO-STRING nil nil)))

(defun lsp-isar-update-goal-without-deadline ()
    "Updates the goal without time limit"
  (interactive)
  (let ((old-timeout lsp-isar-maximal-time))
    (setq lsp-isar-maximal-time nil)
    (lsp-isar--update-state-and-output-buffer lsp-isar--previous-goal)
    (setq lsp-isar-maximal-time old-timeout)))


(defun lsp-isar--update-state-and-output-buffer (content)
  "Updates state and output buffers"
  (condition-case nil
      (let ((parsed-content nil))
	(setq lsp-isar--previous-goal content)
	(save-excursion
	  (with-current-buffer lsp-isar-output-buffer
	    (read-only-mode -1)
	    (setf (buffer-string) ""))
	  (with-temp-buffer
	    (if content
		(progn
		  (insert "$")
		  (insert content)
		  ;; (message (buffer-string))
		  ;; Isabelle's HTML and emacs's HMTL disagree, so
		  ;; we preprocess the output.

		  ;; remove line breaks at beginning
		  (replace-regexp-all-occs "\\$\n*<body>\n" "<body>")

		  ;; add some missing line breaks between error message
		  (replace-regexp-all-occs "</error_message><error_message"
					   "</error_message>\n<error_message")

		  ;; protect spaces and line breaks
		  (replace-regexp-all-occs "\n\\( *\\)"
					   "<break line = 1>'\\1'</break>")


		  (replace-regexp-all-occs "\\(\\w\\)>\\( *\\)<"
					   "\\1><break>'\\2'</break><")

		  ;;(replace-regexp-all-occs "\\(\\w\\)>\"" "\\1>\\\"")

		  ;; (message (buffer-string))
		  ;; (message "%s"(libxml-parse-html-region  (point-min) (point-max)))
		  (setq parsed-content (libxml-parse-html-region (point-min) (point-max))))))
	  (with-current-buffer lsp-isar-state-buffer
	    (let ((inhibit-read-only t))
	      (setf (buffer-string) "")
	      (lsp-isar-parse-output parsed-content)
	      (goto-char (point-min))
	      (ignore-errors
		(search-forward "Proof outline with cases:") ;; TODO this should go to lsp-isar-parse-output
		(setq lsp-isar-proof-cases-content (buffer-substring (point) (point-max))))))
	  (setq lsp-isar-current-output-number (1+ lsp-isar-current-output-number))
	  (with-current-buffer lsp-isar-output-buffer
	    (read-only-mode t))))
    ('abort-rendering
     (message "updating goal interrupted (too slow), use lsp-isar-update-goal-without-deadline")
     nil)))


(defun caddddr (x)
  "Return the `car' of the `cdr' of the `cdr' of the `cdr' of the `cdr' of X."
  (declare (compiler-macro internal--compiler-macro-cXXr))
  (car (cdr (cdr (cdr (cdr x))))))

(defun lsp-isar--update-state-and-output-buffer-async (lsp-isar-current-output-number-res content)
  ;; (message "assync %s" content)
  (let ((original-load-path load-path))
    (async-start
     (lambda ()
       (progn
	 ;; first load all the libraries we need (remember, that this runs in another emacs
	 ;; instance, so the require above do not apply.)
	 (require 'dom)
	 (require 'subr-x)
	 (define-inline remove-quotes-from-string (obj)
	   (inline-letevals (obj)
	     (inline-quote (string-remove-suffix "'" (string-remove-prefix "'" ,obj)))))

	 (define-inline remove-parentheses-from-string (obj)
	   (inline-letevals (obj)
	     (inline-quote (string-remove-suffix "(" (string-remove-prefix ")" ,obj)))))

	 (setq lsp-isar-output-deco nil)
	 (setq lsp-isar-state-deco nil)
	 (setq lsp-isar-state-selected t)
	 (setq lsp-isar-state-buffer (get-buffer-create "*lsp-isar-state*"))
	 (setq lsp-isar-output-buffer (get-buffer-create "*lsp-isar-output*"))
	 (setq lsp-isar-proof-cases-content nil)

	 (set-buffer lsp-isar-state-buffer)

	 (defun replace-regexp-all-occs (REGEXP TO-STRING)
	   "replace-regexp as indicated in the help"
	   (goto-char (point-min))
	   (while (re-search-forward REGEXP nil t)
	     (replace-match TO-STRING nil nil)))
	 (defun lsp-isar-parse-output (contents)
	   "The function iterates over the dynamic output generated by
Isabelle (after preprocessing), in order to generate a goal that
must be printed in Emacs with the syntax highlighting.

It generates the text in the buffers and (in two separate lists) the decorations to be added."
	   (while contents
	     (let ((content (pop contents)))
	       ;; (message "content = %s" content)
	       (cond
		((eq content nil) nil)
		((eq content 'html) nil)
		((stringp content) (insert content))
		((not (listp content))
		 (message "unrecognised %s"
			  content)
		 (insert (format "%s" content)))
		(t
		 (pcase (dom-tag content)
		   ('lsp-isar-select-state-buffer
		    (setq lsp-isar-state-selected t)
		    (set-buffer lsp-isar-state-buffer))
		   ('lsp-isar-fontification
		    (let ((start-point (dom-attr content 'start-point))
			  (face (dom-attr content 'face)))
		      (if lsp-isar-state-selected
			  (push (list start-point (point) face) lsp-isar-state-deco)
			(push (list start-point (point) face) lsp-isar-output-deco))))
		   ('lsp-isar-save-sendback
		    (let ((start-point (dom-attr content 'start-point)))
		      (setq lsp-isar-proof-cases-content
			    (concat
			     lsp-isar-proof-cases-content
			     (buffer-substring start-point (point))))))
		   ('html
		    (setq contents (append (dom-children content) contents)))
		   ('xmlns nil)
		   ('meta nil)
		   ('link nil)
		   ('xml_body nil)
		   ('path nil)

		   ('head
		    (push (car (last (dom-children content))) contents))

		   ('body
		    (setq contents (append (dom-children content) contents)))

		   ('block
		       (insert (if (dom-attr content 'indent) " " ""))
		     (setq contents (append (dom-children content) contents)))

		   ('class
		    (setq contents (append (dom-children content) contents)))

		   ('pre
		    (setq contents (append (dom-children content) contents)))

		   ('state_message
		    (push (dom-node 'break `(('line . 1)) "\n") contents)
		    (setq contents (append (dom-children content) contents)))

		   ('information_message
		    (set-buffer lsp-isar-output-buffer)
		    (setq lsp-isar-state-selected nil)
		    (push (dom-node 'lsp-isar-select-state-buffer ()) contents)
		    (let ((start-point (point)) (face "dotted_information"))
		      (push (dom-node 'lsp-isar-fontification `((start-point . ,start-point) (face . ,face)) nil) contents)
		      (setq contents (append (dom-children content) contents))))

		   ('tracing_message ;; TODO Proper colour
		    (set-buffer lsp-isar-output-buffer)
		    (setq lsp-isar-state-selected nil)
		    (push (dom-node 'lsp-isar-select-state-buffer ()) contents)
		    (let ((start-point (point)) (face "dotted_information"))
		      (push (dom-node 'break `(('line . 1)) "\n") contents)
		      (push (dom-node 'lsp-isar-fontification `((start-point . ,start-point) (face . ,face)) nil) contents)
		      (setq contents (append (dom-children content) contents))))

		   ('warning_message
		    (set-buffer lsp-isar-output-buffer)
		    (setq lsp-isar-state-selected nil)
		    (push (dom-node 'lsp-isar-select-state-buffer ()) contents)
		    (let ((start-point (point)) (face "text_overview_warning"))
		      (push (dom-node 'break `(('line . 1)) "\n") contents)
		      (push (dom-node 'lsp-isar-fontification `((start-point . ,start-point) (face . ,face)) nil) contents)
		      (setq contents (append (dom-children content) contents))))

		   ('legacy_message
		    (set-buffer lsp-isar-output-buffer)
		    (setq lsp-isar-state-selected nil)
		    (push (dom-node 'lsp-isar-select-state-buffer ()) contents)
		    (let ((start-point (point)) (face "text_overview_warning"))
		      (push (dom-node 'break `(('line . 1)) "\n") contents)
		      (push (dom-node 'lsp-isar-fontification `((start-point . ,start-point) (face . ,face)) nil) contents)
		      (setq contents (append (dom-children content) contents))))

		   ('writeln_message
		    (set-buffer lsp-isar-output-buffer)
		    (setq lsp-isar-state-selected nil)
		    (push (dom-node 'lsp-isar-select-state-buffer ()) contents)
		    (let ((start-point (point)) (face "dotted_writeln"))
		      (push (dom-node 'break `(('line . 1)) "\n") contents)
		      (push (dom-node 'lsp-isar-fontification `((start-point . ,start-point) (face . ,face)) nil) contents)
		      (setq contents (append (dom-children content) contents))))

		   ('error_message
		    (set-buffer lsp-isar-output-buffer)
		    (setq lsp-isar-state-selected nil)
		    (push (dom-node 'lsp-isar-select-state-buffer ()) contents)
		    (let ((start-point (point)) (face "text_overview_error"))
		      (push (dom-node 'lsp-isar-fontification `((start-point . ,start-point) (face . ,face)) nil) contents)
		      (setq contents (append (dom-children content) contents))))

		   ('text_fold
		    (setq contents (append (dom-children content) contents)))

		   ('subgoal
		    ;;(set-buffer lsp-isar-state-buffer)
		    (setq contents (append (dom-children content) contents)))

		   ('span
		    (insert (format "%s" (car (last (dom-children content))))))

		   ('position
		    (push (car (last (dom-children content))) contents))

		   ('intensify
		    (let ((start-point (point)) (face "background_intensify"))
		    (push (dom-node 'lsp-isar-fontification `((start-point . ,start-point) (face . ,face)) nil) contents)
		    (setq contents (append (dom-children content) contents))))

		 ('keyword1
		  (let ((start-point (point)) (face "text_keyword1"))
		    (push (dom-node 'lsp-isar-fontification `((start-point . ,start-point) (face . ,face)) nil) contents)
		    (setq contents (append (dom-children content) contents))))

		 ('keyword2
		  (let ((start-point (point)) (face "text_keyword2"))
		    (push (dom-node 'lsp-isar-fontification `((start-point . ,start-point) (face . ,face)) nil) contents)
		    (setq contents (append (dom-children content) contents))))

		 ('keyword3
		  (let ((start-point (point)) (face "text_keyword3"))
		    (push (dom-node 'lsp-isar-fontification `((start-point . ,start-point) (face . ,face)) nil) contents)
		    (setq contents (append (dom-children content) contents))))

		 ('keyword4
		  (let ((start-point (point)) (face "text_keyword4"))
		    (push (dom-node 'lsp-isar-fontification `((start-point . ,start-point) (face . ,face)) nil) contents)
		    (setq contents (append (dom-children content) contents))))

		 ('fixed ;; this is used to enclose other variables
		  (setq contents (append (dom-children content) contents)))

		 ('free
		  (let ((start-point (point)) (face "text_free"))
		    (push (dom-node 'lsp-isar-fontification `((start-point . ,start-point) (face . ,face)) nil) contents)
		    (setq contents (append (dom-children content) contents))))

		 ('inner_string ;; TODO font
		  (setq contents (append (dom-children content) contents)))

		 ('tfree
		  (let ((start-point (point)) (face "text_tfree"))
		    (push (dom-node 'lsp-isar-fontification `((start-point . ,start-point) (face . ,face)) nil) contents)
		    (setq contents (append (dom-children content) contents))))

		 ('tvar
		  (let ((start-point (point)) (face "text_tvar"))
		    (push (dom-node 'lsp-isar-fontification `((start-point . ,start-point) (face . ,face)) nil) contents)
		    (setq contents (append (dom-children content) contents))))

		 ('var
		  (let ((start-point (point)) (face "text_var"))
		    (push (dom-node 'lsp-isar-fontification `((start-point . ,start-point) (face . ,face)) nil) contents)
		    (setq contents (append (dom-children content) contents))))

		 ('bound
		  (let ((start-point (point)) (face "text_bound"))
		    (push (dom-node 'lsp-isar-fontification `((start-point . ,start-point) (face . ,face)) nil) contents)
		    (setq contents (append (dom-children content) contents))))

		 ('skolem
		  (let ((start-point (point)) (face "text_skolem"))
		    (push (dom-node 'lsp-isar-fontification `((start-point . ,start-point) (face . ,face)) nil) contents)
		    (setq contents (append (dom-children content) contents))))

		 ('sendback ;; TODO handle properly
		  (let ((start-point (point)))
		    (push (dom-node 'lsp-isar-save-sendback `((start-point . ,start-point) nil)) contents)
		    (setq contents (append (dom-children content) contents))))

		 ('bullet
		  (insert "•")
		  (setq contents (append (dom-children content) contents)))

		 ('language
		  (setq contents (append (dom-children content) contents)))

		 ('literal
		  (setq contents (append (dom-children content) contents)))

		 ('delimiter
		  (setq contents (append (dom-children content) contents)))

		 ('entity
		  (setq contents (append (dom-children content) contents)))

		 ('paragraph
		  (setq contents (append (dom-children content) contents)))

		 ('dynamic_fact
		  (setq contents (append (dom-children content) contents)))

		 ('item
		  (setq contents (append (dom-children content) contents))) ;; TODO line break

		 ('break
		  (let ((children (mapcar 'remove-quotes-from-string (dom-children content))))
		    (insert (if (dom-attr content 'width) " " ""))
		    (insert (if (dom-attr content 'line) "\n" ""))
		    (mapc 'insert children)))

		 ('xml_elem
		  (setq contents (append (dom-children content) contents)))

		 ('sub ;; Heuristically find the difference between sub and bsub...esub
		  (let ((children (dom-children content)))
		    (if (and
			 (not (cdr children))
			 (stringp (car children)))
			(insert (format "\\<^sub>%s" (car children)))
		      (progn
			(insert "\\<^bsub>")
			(push "\\<^esub>" contents))
		      (setq contents (append children contents)))))

		 ('sup ;; Heuristically find the difference between sup and bsup...esup
		  ;; but we cannot do better as the information is not transmitted
		  (let ((children (dom-children content)))
		    (if (and
			 (not (cdr children))
			 (stringp (car children)))
			(insert (format "\\<^sup>%s" (car children)))
		      (progn
			(insert "\\<^bsup>")
			(push "\\<^esup>" contents))
		      (setq contents (append children contents)))))

		 (_
		  (if (listp (dom-tag content))
		      (progn
			(message "unrecognised node %s" (dom-tag content))
			(insert (format "%s" (dom-tag content)))
			(mapc 'lsp-isar-parse-output (dom-children content)))
		    (progn
		      (message "unrecognised content %s; node is: %s; string: %s %s"
			       content (dom-tag content) (stringp (dom-tag content)) (listp content))
		      (insert (format "%s" (dom-tag content))))))))))))

       (defun lsp-isar--eval-state-and-output-buffer-async (content)
	 "Evaluate output and return it"
	 (setq lsp-isar-maximal-time nil)
	 (let ((parsed-content nil))
	   (setq lsp-isar--previous-goal content)
	   (save-excursion
	     (with-current-buffer lsp-isar-output-buffer
	       (read-only-mode -1)
	       (setf (buffer-string) ""))
	     (with-temp-buffer
	       (if content
		   (progn
		     (insert "$")
		     (insert content)
		     ;; (message (buffer-string))
		     ;; Isabelle's HTML and emacs's HMTL disagree, so
		     ;; we preprocess the output.

		     ;; remove line breaks at beginning
		     (replace-regexp-all-occs "\\$\n*<body>\n" "<body>")

		     ;; add some missing line breaks between error message
		     (replace-regexp-all-occs "</error_message><error_message"
					      "</error_message>\n<error_message")

		     ;; protect spaces and line breaks
		     (replace-regexp-all-occs "\n\\( *\\)"
					      "<break line = 1>'\\1'</break>")


		     (replace-regexp-all-occs "\\(\\w\\)>\\( *\\)<"
					      "\\1><break>'\\2'</break><")

		     ;;(replace-regexp-all-occs "\\(\\w\\)>\"" "\\1>\\\"")

		     ;; (message (buffer-string))
		     ;;(message "%s"(libxml-parse-html-region  (point-min) (point-max)))
		     (setq parsed-content (libxml-parse-html-region (point-min) (point-max))))))
	     (with-current-buffer lsp-isar-state-buffer
	       (let ((inhibit-read-only t))
		 (setf (buffer-string) "")
		 (lsp-isar-parse-output parsed-content)
		 (goto-char (point-min))
		 (setq lsp-isar-state (buffer-string))))
	     (with-current-buffer lsp-isar-output-buffer
	       (read-only-mode t)
	       (setq lsp-isar-output (buffer-string)))
	     (list lsp-isar-state lsp-isar-output lsp-isar-proof-cases-content
		   lsp-isar-state-deco lsp-isar-output-deco))))
       (lsp-isar--eval-state-and-output-buffer-async content)))

    ;; After evaluating the goal asynchronously, we retrieve it and update it in the current
    ;; window.
    (lambda (result)
      (let ((lsp-isar-state (car result))
	    (lsp-isar-output (cadr result))
	    (lsp-isar-proof-cases-content-1 (caddr result))
	    (lsp-isar-state-deco  (cadddr result))
	    (lsp-isar-output-deco (caddddr result)))
	;;(message "result %s" result)
	(setq lsp-isar-proof-cases-content lsp-isar-proof-cases-content-1)
	(if (= lsp-isar-current-output-number lsp-isar-current-output-number-res)
	    (progn
	      (if lsp-isar-output
		  (with-current-buffer lsp-isar-output-buffer
		    (read-only-mode -1)
		    (setf (buffer-string) lsp-isar-output)
		    (read-only-mode t)))
	      (if lsp-isar-state
		  (with-current-buffer lsp-isar-state-buffer
		    (read-only-mode -1)
		    (setf (buffer-string) lsp-isar-state)
		    (read-only-mode t)))))
	(with-current-buffer lsp-isar-state-buffer
	  (dolist (deco lsp-isar-state-deco)
	    (let* ((point0 (car deco))
		   (point1 (cadr deco))
		   (font (caddr deco))
		   (face (cdr (assoc font lsp-isar-get-font)))
		   (ov (make-overlay point0 point1)))
	      (overlay-put ov 'face face))))
	(with-current-buffer lsp-isar-output-buffer
	  (dolist (deco lsp-isar-output-deco)
	    (let* ((point0 (car deco))
		   (point1 (cadr deco))
		   (font (caddr deco))
		   (face (cdr (assoc font lsp-isar-get-font)))
		   (ov (make-overlay point0 point1)))
	      (overlay-put ov 'face face)))))))))

;; deactivate font-lock-mode because we to the fontification ourselves anyway.
(defun lsp-isar-initialize-output-buffer ()
  (setq lsp-isar-state-buffer (get-buffer-create "*lsp-isar-state*"))
  (setq lsp-isar-output-buffer (get-buffer-create "*lsp-isar-output*"))
  (save-excursion
    (with-current-buffer lsp-isar-state-buffer
      (read-only-mode t)
      (isar-goal-mode)
      (font-lock-mode nil))
    (with-current-buffer lsp-isar-output-buffer
      (read-only-mode t)
      (isar-goal-mode)
      (font-lock-mode nil))))

(defun lsp-isar-insert-cases ()
  "insert the last seen outline"
  (interactive)
  (insert lsp-isar-proof-cases-content))

(defun lsp-isar-update-state-and-output-buffer (content)
  "Launch the thread or timer to update the state and the output panel."
  (setq lsp-isar--previous-goal content)
  (if lsp-isar-use-async
      (lsp-isar--update-state-and-output-buffer-async lsp-isar-current-output-number content))

  (if lsp-isar-time-before-printing-goal
      (progn
	(if lsp-isar-proof-timer
	    (cancel-timer lsp-isar-proof-timer))
	(setq lsp-isar-proof-timer
	      (run-at-time lsp-isar-time-before-printing-goal nil
			   (lambda (content)
			     (progn
			       (setq lsp-isar--last-start (time-to-seconds))
			       (lsp-isar--update-state-and-output-buffer content)))
			   content)))))


(modify-coding-system-alist 'file "*lsp-isar-output*" 'utf-8-auto)

(provide 'lsp-output)
